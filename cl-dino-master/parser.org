#+STARTUP: showall indent hidestars

* Введение

Цель данной программы - распарсить сайт. Делать мы это будем, опираясь на считывание
текста с картинки. Для этого нам понадобятся разнообразные библиотеки.

[COMMENT:gmm] Я перенес =defpackage= в блок, где мы загружаем библиотеки,
потому что если ты хочешь иметь возможность исполнять код из отдельных
блоков кода, то они должны работать в том же пакете, в котором объявлены
функции и переменные. А узнать в каком пакете они могут только по форме
~in-package~.

#+NAME: libs
#+BEGIN_SRC lisp :noweb yes
  (eval-when (:compile-toplevel :load-toplevel :execute)
    #-clx
    (ql:quickload 'clx)
    #-zpng
    (ql:quickload 'zpng)
    #-cffi
    (ql:quickload 'cffi)
    (ql:quickload "png-read")
    (ql:quickload :bt-semaphore)
    (ql:quickload :thread-pool))

  (defpackage #:cl-autogui
    (:use #:common-lisp #:xlib)
    (:export #:x-position
             #:x-size
             #:x-position
             #:x-move
             #:x-mouse-down
             #:x-mouse-up
             #:x-click
             #:x-dbclick
             #:x-vscroll
             #:x-hscroll
             #:x-scroll
             #:x-key-down
             #:x-key-up
             #:x-press
             #:x-snapshot
             #:x-snapsearch
             #:x-get-color
             #:x-find-color))
#+END_SRC

Так же нам понадобятся некоторые глобальные переменные, например, keysym-ы, размеры
экрана, размеры скрина и т.д.

#+NAME: defparams
#+BEGIN_SRC lisp
  (in-package  #:cl-autogui)

  (defparameter *langs* "rus+eng")
  (defparameter *default-width* 1295)
  (defparameter *default-height* 668)
  (defparameter *teaser-width* 690)
  (defparameter *snap-width* 755)
  (defparameter *snap-height* 668)
  (defparameter *snap-x* 440)
  (defparameter *default-x* 60)
  (defparameter *default-y* 37)
  (defparameter *mouse-left* 1)
  (defparameter *mouse-middle* 2)
  (defparameter *hh-teaser-url*
    "https://hh.ru/search/vacancy?L_is_autosearch~false&area=2&clusters=true&enable_snippets=true&items_on_page=100&only_with_salary=true&salary=165000&specialization=1.221&page~~A"
    "https://spb.hh.ru/search/vacancy?L_is_autosearch~false&area=1&clusters=true&enable_snippets=true&items_on_page=100&only_with_salary=true&salary=165000&specialization=1.221&page~~A")

  (defparameter *browser-path*  "/usr/bin/firefox")
#+END_SRC

* Получение скрина

Чтоб получить скрины с какого-либо сайта, надо сначала открыть сам сайт.
С помощью ~run-programm~ запускаем браузер (в нашем случае это firefox) с
заданным URL.

#+NAME: open-browser
#+BEGIN_SRC lisp
  (in-package  #:cl-autogui)

  (defun open-browser (browser-path url)
    (let ((proc (sb-ext:run-program
                 `,browser-path
                 `(,url)
                 :input :stream :output :stream)))
      (if proc
          (with-open-stream (input (sb-ext:process-input proc))
            (with-open-stream (output (sb-ext:process-output proc))
              (do ((a-line (read-line output nil 'eof)
                           (read-line output nil 'eof)))
                  ((eql a-line 'eof))
                (format t "~A" a-line)
                (force-output output))))
      (format t "~% open-browser: didn't run firefox"))))

  ;; (block open-browser-test
  ;;  (open-browser "/usr/bin/firefox" *hh-teaser-url*))
#+END_SRC

Браузер открыли. Теперь хорошо бы сделать скрин. Но прежде чем его делать,
обзаведемся макросами, которые будут работать с нашим дисплеем.

#+NAME: display-macros
#+BEGIN_SRC lisp
  (in-package  #:cl-autogui)

  (defmacro with-display (host (display screen root-window) &body body)
    `(let* ((,display (xlib:open-display ,host))
            (,screen (first (xlib:display-roots ,display)))
            (,root-window (xlib:screen-root ,screen)))
       (unwind-protect (progn ,@body)
         (xlib:close-display ,display))))

  (defmacro with-default-display ((display &key (force nil)) &body body)
    `(let ((,display (open-default-display)))
       (unwind-protect
            (unwind-protect
                 ,@body
              (when ,force
                (display-force-output ,display)))
         (close-display ,display))))

  (defmacro with-default-display-force ((display) &body body)
    `(with-default-display (,display :force t) ,@body))

  (defmacro with-default-screen ((screen) &body body)
    (let ((display (gensym)))
      `(with-default-display (,display)
         (let ((,screen (display-default-screen ,display)))
           ,@body))))

  (defmacro with-default-window ((window) &body body)
    (let ((screen (gensym)))
      `(with-default-screen (,screen)
         (let ((,window (screen-root ,screen)))
           ,@body))))
#+END_SRC

Теперь можно получить и функцию, которая сделает нам скрин.
Она принимает X и Y координаты, от которых скрин будет начинаться, размер этого скрина
(по умолчанию размеры окна браузера) и путь, по которму скрин следует сохранить.
Возвращает массив RGB, т.е. массив с пикселями текущего скрина типа zpng:data-array.
Основная заковыка с этим массивом состояит в том, что при обращении к какому-то его
элементу, следуюет сначала указывать Y, а потом X. Например (aref image-data y x 1).

#+NAME: x-snapshot
#+BEGIN_SRC lisp :noweb yes
  (in-package  #:cl-autogui)

  <<raw_image_png>>

  (defun x-snapshot (&key (x *default-x*) (y *default-y*)
                       (width  *default-width*) (height *default-height*)
                       path)
    ;; "Return RGB data array (The dimensions correspond to the height, width,
    ;; and pixel components, see comments in x-snapsearch for more details),
    ;; or write to file (PNG only), depend on if you provide the path keyword"
    (with-default-window (w)
      (let ((image
             (raw-image->png
              (xlib:get-raw-image w :x x :y y
                                  :width width :height height
                                  :format :z-pixmap)
              width height)))
        (if path
            (let* ((ext (pathname-type path))
                   (path
                    (if ext
                        path
                        (concatenate 'string path ".png")))
                   (png? (or (null ext) (equal ext "png"))))
              (cond
                (png? (zpng:write-png image path))
                (t (error "Only PNG file is supported"))))
            (zpng:data-array image)))))

  ;; (block save-load-binarixation-test
  ;;   (x-snapshot :x *snap-height*
  ;;               :width  *snap-width*
  ;;               :path "~/Pictures/snapshot-test.png"))
#+END_SRC

Внимательный читатель заметил, что x-snapshot вызывает raw-image->png. Зачем? Дело в
том, что изначально массив пикселей организован по принципу BRG и чтоб получить
привычный нам формат RGB, необходимо массив подкорректировать. Это и делает raw-image->png.

#+NAME: raw_image_png
#+BEGIN_SRC lisp
  (in-package  #:cl-autogui)

  (defun raw-image->png (data width height)
    (let* ((png (make-instance 'zpng:png :width width :height height
                               :color-type :truecolor-alpha
                               :image-data data))
           (data (zpng:data-array png)))
      (dotimes (y height)
        (dotimes (x width)
          ;; BGR -> RGB, ref code: https://goo.gl/slubfW
          ;; diffs between RGB and BGR: https://goo.gl/si1Ft5
          (rotatef (aref data y x 0) (aref data y x 2))
          (setf (aref data y x 3) 255)))
      png))
#+END_SRC

* Работа с изображениями

Потрясающе! Теперь мы можем получить скрин. Но что насчет его сохранения,
загрузки изображения, его бинаризации и т.д.?

Эта функция сохранит переданный массив пикселей как изображение. Для этого ей нужны
размеры скрина и путь, по кторому следует картинку сохранить.

#+NAME: save-png
#+BEGIN_SRC lisp :noweb yes
  (in-package  #:cl-autogui)

  (defun save-png (width height pathname-str image
                   &optional (color-type :truecolor-alpha))
    (let* ((png (make-instance 'zpng:png :width width :height height
                               :color-type color-type))
           (vector (make-array ;; displaced vector - need copy for save
                    (* height width (zpng:samples-per-pixel png))
                    :displaced-to image :element-type '(unsigned-byte 8))))
      ;; Тут применен потенциально опасный трюк, когда мы создаем
      ;; объект PNG без данных, а потом добавляем в него данные,
      ;; используя неэкспортируемый writer.
      ;; Это нужно чтобы получить третью размерность массива,
      ;; который мы хотим передать как данные и при этом
      ;; избежать создания для этого временного объекта
      (setf (zpng::%image-data png) (copy-seq vector))
      (zpng:write-png png pathname-str)))

  <<load_png>>

  <<binarization>>

  ;; <<save-load-binarization-test>>
#+END_SRC

Сохранили? Теперь бы еще неплохо бы загрузить изображение.
~Load-png~ принимает путь к файлу, а возвращает его массив типа
~zpng:data-array~.

#+NAME: load_png
#+BEGIN_SRC lisp
  (in-package  #:cl-autogui)

  (defun load-png (pathname-str)
    "Возвращает массив size-X столбцов по size-Y точек,
     где столбцы идут слева-направо, а точки в них - сверху-вниз
     ----
     В zpng есть указание на возможные варианты COLOR:
     ----
           (defmethod samples-per-pixel (png)
             (ecase (color-type png)
               (:grayscale 1)
               (:truecolor 3)
               (:indexed-color 1)
               (:grayscale-alpha 2)
               (:truecolor-alpha 4)))
    "
    (let* ((png (png-read:read-png-file pathname-str))
           (image-data (png-read:image-data png))
           (color (png-read:colour-type png))
           (dims (cond ((or (equal color :truecolor-alpha)
                            (equal color :truecolor))
                        (list (array-dimension image-data 1)
                              (array-dimension image-data 0)
                              (array-dimension image-data 2)))
                       ((or (equal color :grayscale)
                            (equal color :greyscale))
                        (list (array-dimension image-data 1)
                              (array-dimension image-data 0)))
                       (t (error 'unk-png-color-type :color color))))
           (result ;; меняем размерности X и Y местами
            (make-array dims :element-type '(unsigned-byte 8))))
      ;; (format t "~% new-arr ~A "(array-dimensions result))
      ;; ширина, высота, цвет => высота, ширина, цвет
      (macrolet ((cycle (&body body)
                   `(do ((y 0 (incf y)))
                        ((= y (array-dimension result 0)))
                      (do ((x 0 (incf x)))
                          ((= x (array-dimension result 1)))
                        ,@body))))
        (cond ((or (equal color :truecolor-alpha)
                   (equal color :truecolor))
               (cycle (do ((z 0 (incf z)))
                          ((= z (array-dimension result 2)))
                        (setf (aref result y x z)
                              (aref image-data x y z)))))
              ((or (equal color :grayscale)
                   (equal color :greyscale))
               (cycle (setf (aref result y x)
                            (aref image-data x y))))
              (t (error 'unk-png-color-type :color color)))
        result)))
#+END_SRC

Ну и вишенка на торте - бинаризация изображения. Зачем? Во-первых, анализировать
бинарное изображение проще и быстрее, во-вторых, его лучше распознает нейросеть
тесеракт.

Функция принимает массив изображения и порог, который укажет, что считать белым, а
что - черным. Например, если вы укажете порог 127, то все, что будет иметь цвет пикселя
выше 127, будет считаться белым.
Возвращает бинаризованный массив.

#+NAME: binarization
#+BEGIN_SRC lisp :noweb yes
  (in-package  #:cl-autogui)

  <<condition>>

  (defun binarization (image &optional threshold)
    (let* ((dims (array-dimensions image))
           (new-dims (cond ((equal 3 (length dims))  (butlast dims))
                           ((equal 2 (length dims))  dims)
                           (t (error 'binarization-error))))
           (result (make-array new-dims :element-type '(unsigned-byte 8))))
      (macrolet ((cycle (&body body)
                   `(do ((y 0 (incf y)))
                        ((= y (array-dimension image 0)))
                      (do ((x 0 (incf x)))
                          ((= x (array-dimension image 1)))
                        ,@body))))
        (cond ((equal 3 (length dims))
               (cycle (do ((z 0 (incf z)))
                          ((= z (array-dimension image 2)))
                        (let ((avg (floor (+ (aref image y x 0)
                                             (aref image y x 1)
                                             (aref image y x 2))
                                          3)))
                          (when threshold
                            (if (< threshold avg)
                                (setf avg 255)
                                (setf avg 0)))
                          (setf (aref result y x) avg)))))
              ((equal 2 (length dims))
               (cycle (let ((avg (aref image y x)))
                        (when threshold
                          (if (< threshold avg)
                              (setf avg 255)
                              (setf avg 0)))
                        (setf (aref result y x) avg))))
              (t (error 'binarization-error))))
      result))
#+END_SRC

Хорошо бы еще засечь ошибку, когда мы пытаемся прочитать png,
в котором неизвестно сколько байт на точку.

#+NAME: condition
#+BEGIN_SRC lisp :noweb yes
  (in-package  #:cl-autogui)

  ;; Ошибка, возникающая когда мы пытаемся прочитать png
  ;; в котором неизвестно сколько байт на точку
  (define-condition unk-png-color-type (error)
    ((color :initarg :color :reader color))
    (:report
     (lambda (condition stream)
       (format stream "Error in LOAD-PNG: unknown color type: ~A"
               (color condition)))))
#+END_SRC

Последнее, чего нам не хватает - это тесты, чтоб проверить всю эту красоту.

#+NAME: save-load-binarization-test
#+BEGIN_SRC lisp
  (in-package  #:cl-autogui)

  (block save-load-binarixation-test
    (x-snapshot :x 440 :width  *snap-width*
                :path "~/Pictures/test.png")
    (let* ((image (load-png "~/Pictures/test.png"))
           (image (binarization image 200)))
      (destructuring-bind (dh dw)
          (array-dimensions image)
        (save-png dw dh "~/Pictures/test-bin.png"
                 image  :grayscale))))

  (block save-load-full-color-test
    (x-snapshot :x 440 :width *snap-width*
                :path "~/Pictures/test.png")
    (sleep .1)
    (let* ((image (load-png "~/Pictures/test.png")))
    (destructuring-bind (dh dw colors)
        (array-dimensions image)
      (save-png dw dh "~/Pictures/test-full-color.png" image))))
#+END_SRC

* фейковые события клавиатуры
:PROPERTIES:
:xtest: xlib/xtest
:END:

NB: По какой-то странной причине (предположительно - разные версии
библиотеки-враппера ~xlib~) тут есть проблема с вызовом функций из пакета
~xtest=. В одной конфигурации пакет должен быть обьявлен как =xtest~, а в
другой - как ~xlib/xtest~. Чтобы нивелировать подобные различия я
использовал механизм ~properties=, объявив property =xtest~ и обращаясь к
нему когда мы танглим исходный код в файл. Теперь будет достаточно
изменить это в одном месте и перегенерировать код.

#+NAME: get_property
#+BEGIN_SRC elisp :var prop=""
  (org-entry-get nil prop t)
#+END_SRC

Итак, мы невероятные молодцы, научились делать скрин и взаимодейстсовть с ним. Но чтоб
парсить сайт, надо странички скролить, на ссылочки нажимать и вообще симулировать
бурную деятельность.

В этом нам помогут следующие вспомогательные функции.

#+NAME: fake-events
#+BEGIN_SRC lisp :noweb yes
  (in-package  #:cl-autogui)

  (defun x-size ()
    (with-default-screen (s)
      (values
       (screen-width s)
       (screen-height s))))

  (defun x-move (x y)
    (if (and (integerp x) (integerp y))
        (with-default-display-force (d)
          (<<get_property("xtest")>>:fake-motion-event d x y))
        (error "Integer only for position, (x: ~S, y: ~S)" x y)))

  (defun mklist (obj)
    (if (and
         (listp obj)
         (not (null obj)))
        obj (list obj)))

  (defmacro defun-with-actions (name params actions &body body)
    ;; "This macro defun a function which witch do mouse or keyboard actions,
    ;; body is called on each action."
    `(defun ,name ,params
       (mapcar
        #'(lambda (action)
            ,@body)
        (mklist ,actions))))

  (macrolet ((def (name actions)
               `(defun-with-actions ,name
                    (&key (button 1) x y)
                    ,actions
                  (funcall #'perform-mouse-action
                           action button :x x :y y))))
    (def x-mouse-down t)
    (def x-mouse-up nil)
    (def x-click '(t nil))
    (def x-dbclick '(t nil t nil)))

  (defmacro with-scroll (pos neg clicks x y)
    `(let ((button (cond
                     ((= 0 ,clicks) nil)
                     ((> 0 ,clicks) ,pos)    ; scroll up/right
                     ((< 0 ,clicks) ,neg)))) ; scroll down/left
       (dotimes (_ (abs ,clicks))
         (x-click :button button :x ,x :y ,y))))

  (defun x-vscroll (clicks &key x y)
    (with-scroll 4 5 clicks x y))

  (defun x-scroll (clicks &key x y)
    (x-vscroll clicks :x x :y y))

  (defun x-hscroll (clicks &key x y)
    (with-scroll 7 6 clicks x y))

  (macrolet ((def (name actions)
               `(defun-with-actions ,name (keycode)
                    ,actions
                  (funcall #'perform-key-action
                           action keycode))))
    (def x-key-down t)
    (def x-key-up nil)
    (def x-press '(t nil)))

  <<mouse-and-key-actions>>
#+END_SRC

Глядя на все это многообразие можно ужаснуться, но напрямую мы будем взаимодейстсовать
только с этими двумя функциями.

~perform-mouse-action= создает фейковое событие мышки, а =perform-key-action~ создает
фейковое событие клаиватуры. Обе функции принимают первым параметров t или nil, что
соответствует "нажать" и "отпустить" в переводе на человеческий, затем
~keysym=. =perform-mouse-action~ принимает еще и координаты, куда следует кликнуть
"мышкой".

#+NAME: mouse-and-key-actions
#+BEGIN_SRC lisp :noweb yes
    (in-package  #:cl-autogui)

    ;; (defun perform-mouse-action (press? button &key x y)
    ;;   (and x y (x-move x y))
    ;;   (with-default-display-force (d)
    ;;     (<<get_property("xtest")>>:fake-button-event d button press?)))

    ;; (defun perform-key-action (press? keycode) ; use xev to get keycode
    ;;   (with-default-display-force (d)
    ;;     (<<get_property("xtest")>>:fake-key-event d keycode press?)))

  (defun perform-mouse-action (press? button &key x y)
    (and x y (x-move x y))
    (with-default-display-force (d)
      (xlib/xtest:fake-button-event d button press?)))

  (defun perform-key-action (press? keycode) ; use xev to get keycode
    (with-default-display-force (d)
      (xlib/xtest:fake-key-event d keycode press?)))

    ;; (block perform-key-action-test
    ;;   (perform-key-action t 116)
    ;;   (sleep .1)
    ;;   (perform-key-action nil 116))

    ;; (block perform-mouse-action-test
    ;;   (perform-mouse-action t *mouse-left* :x 100 :y 100)
    ;;   (sleep .1)
    ;;   (perform-mouse-action nil *mouse-left* :x 100 :y 100))
#+END_SRC

* анализ и склейка изображений

Итак, теперь мы способны открыть браузер, получить скрины, сохранить их, загрузить и
бинаризировать. Но для парсинга этого мало.

Чтоб анализировать было проще и быстрее, мы сначала получим свиток, склеенный из всех
скринов текущей страницы сайта, затем разрежем его на куски и передадим анализировать
тесеракту.

Как понять, где клеить?
Для этого воспользуемся простой логической операцией ~xor~. Xor  - "исключающее или",
по-другому, - выдает 0, если 2 его операнда совпадают, и дает 1, если операнды не
совпадают. Мы возьмем 2 скрина и будем строчка за строчкой накладывать последний скрин
на предыдущий до тех пор, пока не увидим максимально черное изображение. Ведь это
значит, что, анализируя 2 пикселя (с первой и второй картинки), xor дал 0, что означает
одинаковый цвет у пикселей. После этого мы склеим изображение и будем анализировать
следующие картинки.

В этой идее есть множество нюансов, которые мы будем постепенно разбирать.

** Нюанс №1. Скорость.

Анализировать полноцветные иображения жутко долго и энергозатратно. Поэтму мы будем
сначала их бинаризировать, а затем превращать в битовые массивы.

В этом нам поможет make-bit-image, которая принимает бинаризированный массив
изображения, а возвращает его битовый аналог.

#+NAME: make-bit-image
#+BEGIN_SRC lisp
  (in-package  #:cl-autogui)

  (defun make-bit-image (image-data)
    (destructuring-bind (height width &optional colors)
        (array-dimensions image-data)
      ;; функция может работать только с бинарными изобажениями
      (assert (null colors))
      (let* ((new-width (+ (logior width 7) 1))
             (bit-array (make-array (list height new-width)
                                    :element-type 'bit)))
        (do ((qy 0 (incf qy)))
            ((= qy height))
          (do ((qx 0 (incf qx)))
              ((= qx width))
            ;; если цвет пикселя не белый, считаем,
            ;; что это не фон и заносим в битовый массив 1
            (unless (equal (aref image-data qy qx) 255)
              (setf (bit bit-array qy qx) 1))))
        bit-array)))

  ;; (block make-bit-image
  ;;     (time
  ;;      (let* ((bit-arr1
  ;;              (make-bit-image (load-png "~/Pictures/test-bin.png"))))
  ;;        (format t "~% ~A" bit-arr1))))
#+END_SRC

Теперь, когда мы получили битовый массив, хорошо бы разобраться с xor-ом. Для этого
напишем две функции: ~append-xor= и =xor-area~.

~Append-xor~ принимает 2 массива изображений и высоту, где второе изображение будет
наложено на первое с помощью XOR. Изображения должны быть одинаковой ширины
и иметь одинаковое количество байт на пиксель. Возвращает склеенный массив.

#+NAME: append-xor
#+BEGIN_SRC lisp :noweb yes
  (in-package  #:cl-autogui)

  (defun append-xor (image-up image-down y-point)
    (destructuring-bind (height-up width-up &optional colors-up)
        (array-dimensions image-up)
      (destructuring-bind (height-down width-down &optional colors-down)
          (array-dimensions image-down)
        (assert (equal width-up width-down))
        (assert (equal colors-up colors-down))
        (let* ((new-height (+ height-down y-point))
               (new-dims (if (null colors-down)
                             (list new-height width-down)
                             (list new-height width-down colors-down)))
               (image-new (make-array new-dims :element-type '(unsigned-byte 8))))
          ;; макрос для прохода по блоку точек
          (macrolet ((cycle ((py px height width &optional &body newline)
                             &body body)
                       `(do ((qy ,py (incf qy)))
                            ((= qy ,height))
                          (do ((qx ,px (incf qx)))
                              ((= qx ,width))
                            ,@body)
                          ,@newline)))
            ;; копируем первую картинку в новый массив
            ;; от ее начала до ее конца (NB: тут отличие от append-image)
            (if (null colors-up)
                (cycle (0 0 height-up width-up)
                       (setf (aref image-new qy qx)
                             (aref image-up qy qx)))
                ;; else
                (cycle (0 0 height-up width-up)
                       (do ((qz 0 (incf qz)))
                           ((= qz colors-up))
                         (setf (aref image-new qy qx qz)
                               (aref image-up qy qx qz)))))
            ;; xor-им вторую картинку в новый массив
            ;; от ее начала до конца
            (if (null colors-down)
                (let ((new-y y-point))
                  (cycle (0 0 height-down width-down (incf new-y))
                         (setf (aref image-new new-y qx)
                               (logxor (aref image-new new-y qx)
                                       (aref image-down qy qx)))))
                ;; else
                (let ((new-y y-point))
                  (cycle (0 0 height-down width-down (incf new-y))
                         ;; ксорим 3 цвета
                         (do ((rz 0 (incf rz)))
                             ((= rz colors-down))
                           (setf (aref image-new new-y qx rz)
                                 (logxor (aref image-new new-y qx rz)
                                         (aref image-down qy qx rz))))
                         ;; копируем альфа-канал
                         (setf (aref image-new new-y qx 3)
                               (aref image-down qy qx 3))
                         ))))
          image-new))))

  ;; (time
  ;;  (block test-append-xor-fullcolor
  ;;    (let* ((arr1 (x-snapshot :x 0 :y 0 :width 500 :height 300))
  ;;           (arr2 (x-snapshot :x 0 :y 100 :width 500 :height 300))
  ;;           (result (append-xor arr1 arr2 200)))
  ;;      (destructuring-bind (height width  &rest rest)
  ;;          (array-dimensions result)
  ;;        (save-png width height "~/Pictures/result.png" result)))))

  ;; (block test-append-xor-grayscale
  ;;   (let* ((arr1 (binarization (x-snapshot :x 0 :y 0 :width 755 :height 300)))
  ;;          (arr2 (binarization (x-snapshot :x 0 :y 100 :width 755 :height 300)))
  ;;          (array (append-xor arr1 arr2 200)))
  ;;     (destructuring-bind (height width  &rest rest)
  ;;         (array-dimensions array)
  ;;       (save-png width height "~/Pictures/result.png" array :grayscale))))

  <<xor_area>>

#+END_SRC

xor-area работает почти так же, как append-xor.
Так же получает на вход 2 массива изображений (изображения должны иметь одинаковую
ширину и кол-во байт на пиксель) и точку, от которой начнется наложение.
Накладывает одно изображение на другое, но копирует только сксоренные пиксели,
т.е. исключительно область наложения одной картинки на другую.

Ограничение: y-point не должен быть больше и равен высоте ихображения, на которое мы
накладываем. Иначе мы выходим за границы массива.

#+NAME: xor_area
#+BEGIN_SRC lisp :noweb yes
  (in-package  #:cl-autogui)

(defun xor-area (image-up image-down y-point)
  (destructuring-bind (height-up width-up &optional colors-up)
      (array-dimensions image-up)
    (destructuring-bind (height-down width-down &optional colors-down)
        (array-dimensions image-down)
      ;; (format t "~% height-up ~A width-up ~A height-down ~A width-down ~A y ~A"
      ;;         height-up width-up height-down width-down y-point)
      (assert (equal width-up width-down))
      (assert (equal colors-up colors-down))
      (if (>= y-point height-up)
          nil
          (let* ((new-height (+ height-down y-point))
                 (new-dims (if (null colors-down)
                               (list new-height width-down)
                               (list new-height width-down colors-down)))
                 (image-new (make-array new-dims :element-type '(unsigned-byte 8))))
            ;; макрос для прохода по блоку точек
            (macrolet ((cycle ((py px height width &optional &body newline)
                               &body body)
                         `(do ((qy ,py (incf qy)))
                              ((= qy ,height))
                            (do ((qx ,px (incf qx)))
                                ((= qx ,width))
                              ,@body)
                            ,@newline)))
              ;; для бинарных изображений
              (if (null colors-down)
                  (let ((new-y y-point))
                    ;; (- height-up y-point) = высота области наложения
                    (cycle (0 0 (- height-up y-point) width-down (incf new-y))
                           (setf (aref image-new qy qx)
                                 (logxor (aref image-up new-y qx)
                                         (aref image-down qy qx)))))
                  ;; для full-color изображений
                  (let ((new-y y-point))
                    (cycle (0 0 (- height-up y-point) width-down (incf new-y))
                           ;; ксорим 3 цвета
                           (do ((rz 0 (incf rz)))
                               ((= rz (- colors-down 1)))
                             (setf (aref image-new qy qx rz)
                                   (logxor (aref image-up new-y qx rz)
                                           (aref image-down qy qx rz))))
                           ;; копируем альфа-канал
                           (setf (aref image-new qy qx 3)
                                 (aref image-down qy qx 3))
                           ))))
            image-new)))))

  ;; (block xor-area-test
  ;;   (time
  ;;   (let* ((arr1 (binarization (load-png "~/Pictures/test-bin.png") 200))
  ;;          (arr2 (binarization (load-png "~/Pictures/test-bin.png") 200))
  ;;          (array (xor-area arr1 arr2 200)))
  ;;              (destructuring-bind (height width  &rest rest)
  ;;                 (array-dimensions array)
  ;;                (save-png width height "~/Pictures/area.png" array :grayscale)))))

  <<append-image>>

#+END_SRC

** Нюанс №2. Нахождение самого черного изображения.

Необходимые понятия:
~область наложения~ - область, где одно изображение накладывается
на другое. Область наложения не может иметь бОльшую высоту, чем высота накладываемого
изображения.

~общий пулл результатов~ - список, который содержит в себе лучшие результаты
для всех обработанных картинок и массивы самих картинок

~текущий пулл результатов~ - список, который содержит в себе все результаты анализа
текущей пары картинок
~image-up~ это изображение, которое находится выше по рулону страницы выдачи. Это
просто ранее полученное изображение. При наложении мы будем накладывать НА него
~image-down~ - это более позднее изображение, находится ниже по рулону. ПРи наложениее
мы будем накладывать ЕГО.

Как найти наиболее подходящее изображение?
Будем накладывать последний скрин на предущий снизу вверх, строка за строкой, пока не
кончится высота последнего скрина, считать, сколько пикселей "почернело" из-за xor-a и
сохранять результат в текущий пулл результатов. После того, как весь цикл накладывания пройден,
выберем наилучший результат, а затем склеим.

В качестве результата единичного анализа будем сохранять кол-во черных пискселей,
кол-во белых пискселей и координату ~Y~, на которой это кол-во было получено в
виде cons-пары: (( черные_точки . белые точки ). y-point).

Пожалуй, начнем с наиболее простого: склейка.

append-image принимает 2 массива с изображениями, которые должны иметь одинаковую
ширину и кол-во байт на пиксель, точку, от которой будет производиться склейка,
и возвращает склеенный массив.

#+NAME: append-image
#+BEGIN_SRC lisp :noweb yes
  (in-package  #:cl-autogui)

  (defun append-image (image-up image-down y-point)
    (destructuring-bind (height-down width-down &optional colors-down)
        (array-dimensions image-down)
      (let* ((new-height (+ height-down y-point))
             (new-dims (if (null colors-down)
                           (list new-height width-down)
                           (list new-height width-down colors-down)))
             (image-new (make-array new-dims :element-type '(unsigned-byte 8))))
        ;; макрос для прохода по блоку точек
        (macrolet ((cycle ((py px height width &optional &body newline)
                           &body body)
                     `(do ((qy ,py (incf qy)))
                          ((= qy ,height))
                        (do ((qx ,px (incf qx)))
                            ((= qx ,width))
                          ,@body)
                        ,@newline)))
          ;; копируем первую картинку в новый массив
          ;; от ее начала до точки склейки, или до ее конца,
          ;; смотря что случится раньше
          (if (null colors-down)  ;; TODO: тут надо проверять цвета первой картинки
              ;;(cycle (0 0 (min height-down y-point) width-down)
              (cycle (0 0 y-point width-down)
                     (setf (aref image-new qy qx)
                           (aref image-up qy qx)))
              ;; else
              (cycle (0 0 y-point width-down)
                     (do ((qz 0 (incf qz)))
                         ((= qz colors-down))
                       (setf (aref image-new qy qx qz)
                             (aref image-up qy qx qz)))))
          ;; копируем вторую картинку в новый массив
          ;; от ее начала до конца
          (if (null colors-down)
              (let ((new-y y-point))
                (cycle (0 0 height-down width-down (incf new-y))
                       (setf (aref image-new new-y qx)
                             (aref image-down qy qx))))
              ;; else
              (let ((new-y y-point))
                (cycle (0 0 height-down width-down (incf new-y))
                       (do ((rz 0 (incf rz)))
                           ((= rz colors-down))
                         (setf (aref image-new new-y qx rz)
                               (aref image-down qy qx rz)))))))
        image-new)))

  ;; (block test-append-image-fullcolor
  ;;   (let* ((arr1 (x-snapshot :x 0 :y 0 :width 755 :height 300))
  ;;          (arr2 (x-snapshot :x 100 :y 100 :width 755 :height 300))
  ;;          (array (append-image arr1 arr2 200)))
  ;;     (destructuring-bind (height width  &rest rest)
  ;;         (array-dimensions array)
  ;;       (save-png width height "~/Pictures/result.png" array))))


  ;; (block test-append-image-grayscale
  ;;   (let* ((arr1 (binarization (x-snapshot :x 0 :y 0 :width 755 :height 300)))
  ;;          (arr2 (binarization (x-snapshot :x 0 :y 0 :width 755 :height 300)))
  ;;          (array (append-image arr1 arr2 200)))
  ;;     (destructuring-bind (height width  &rest rest)
  ;;         (array-dimensions array)
  ;;       (save-png width height "~/Pictures/result.png" array :grayscale))))

  <<analysis>>
#+END_SRC

** Нюанс №3. Анализ изображений.

Собственно, а как мы будем анализировать-то?
Во-первых, область наложения у нас меняется, мы ж снизу вверх двигаемся, значит, она
увеличивается. Значит, просто считать черные пиксели нельзя, ведь чем больше
изображение, тем больше там черных пикселей окажется. А, во-вторых, считать более 600
раз (или какая там у вас высота последнего скрина?) кол-во черных пикселей - это жуть
как долго.

Поэтому мы установим порог "нечерных" пикселей, выше которого подниматься нельзя. В
случае, если этот порог будет превышен, мы перестаем считать и поднимаемся выше, не
занося ничего в пулл результатов.

Для этого нам нужна функция analysis. Она принимает уже отксоренное изображение, точку
наложения, откуда будет производить анализ и порог белых пикселей, который по
умолчанию равен 50% от общего количества пикселей в области наложения.


#+NAME: analysis
#+BEGIN_SRC lisp :noweb yes
  (in-package  #:cl-autogui)
(defun analysis (xored-image y-point &optional (border 50))
  "Принимает отксоренное изображение и y-координату  наложения,
   т.е. точку, от которой будет производиться анализ.
   Анализирует кол-во почерневших точек на изображении, возвращает cons-пару типа
   (% черных точек . y-point)"
  (if (null xored-image)
      nil
      (destructuring-bind (height width &optional colors)
          (array-dimensions xored-image)
        ;;(format t "~% y-point ~A height ~A" y-point height)
        (let* ((intesect-height (- height y-point)) ;; высота пересечения
               (white 0)
               (black 0)
               ;; общее кол-во пикселей в области наложения
               (pix-amount (* intesect-height width)))
          ;; (format t "~% intersect-height ~A" intesect-height)
          ;; высчитываем максимально допустимое количество белых пикселей
          (setf border (* (float (/ border 100)) pix-amount))
          ;;(format t "~% intesect-height ~A " intesect-height)
          ;; если картинки full-color
          (if colors
              (do ((qy y-point (incf qy)))
                  ((= qy height))
                ;; если кол-во нечерных пикселей больше 25%
                (if (> white border)
                    (progn
                      ;; не анализируя дальше, возвращаем nil
                      (return-from analysis))
                    ;; в противном случае анализиуем следующий ряд пикселей
                    (do ((qx 0 (incf qx)))
                        ((= qx width))
                      (when (not (and (eql (aref xored-image qy qx 0) 0)
                                      (eql (aref xored-image qy qx 1) 0)
                                      (eql (aref xored-image qy qx 2) 0)))
                        (incf white)))))
              ;; то же самое для бинарных изображений
              (do ((qy y-point (incf qy)))
                  ((= qy height))
                (if (> white border)
                    (progn
                      (return-from analysis ))
                    (do ((qx 0 (incf qx)))
                        ((= qx width))
                      (when (not (eql (aref xored-image qy qx) 0))
                        (incf white))))))
          ;; эта часть выполнится только если все циклы выполнены успешно
          ;; считаем кол-во черных пикселей
          (setf black ( - pix-amount white))
          (let ((result (cons (* (float (/ black pix-amount)) 100)
                              (* (float (/ white pix-amount)) 100))))
            ;;(format t " ~% black ~A y-point ~A pixamount ~A" black y-point pix-amount)
            ;; возвращаем кол-во черных пикселей в процентном выражении
            result)))))

  ;; (block analysis-test
  ;;   (let* ((arr1 (binarization (load-png "~/Pictures/test-bin.png") 200))
  ;;          (arr2 (binarization (load-png "~/Pictures/test-bin.png") 200))
  ;;          (array (xor-area arr1 arr2 200))
  ;;          (results (cons (analysis
  ;;                          array 200 80)
  ;;                         200)))
  ;;     (format t " ~% results ~A" results)))

#+END_SRC

** Нюанс №4. Сборка.

Как все это собрать и чтоб оно не тормозило?
Сделаем несколько потока: основной будет скринить страницу выдачи, остальные будут ее
анализировать.

Для этого мы создадим пул тасков - заданий для потоков. Чтоб не открывать и закрывать
потоки до бесконечности, создадим пулл из потоков (кол-во ядер - 1),
которые будут брать задание по очереди и выполнять его.

Для начала напишем функцию сбора данных.
Если тасков еще/уже нет, мы считаем, что функция запускалась в первый раз и нам нужно
сделать 2 скриншота, т.к. для составления задания нужна пара изображений.

В противном случае мы загружаем предыдущее сохраненное изображение и делаем 1 новый
скриншот.

Есть офлайн вариант: он просто создает таски из уже имеющихся изображений. На данный
момент ссылок на него нет.

#+NAME: get_data
#+BEGIN_SRC lisp :noweb yes
  (in-package  #:cl-autogui)

<<get-data-ofline>>

    (defun get-data (image-up-path image-down-path)
      ;; если тасков нет, а занчит, нет и пары изображений
      (if (eql (fill-pointer tasks) 0)
          ;; сделать скриншот
          (let ((image-up
                 (binarization
                  (x-snapshot :x 440 :y 100 :width *snap-width* :height *snap-height*))))
            ;; провертим экран вниз
            (perform-key-action t 117)
            (sleep .1)
            (perform-key-action nil 117)
            (sleep .5)
            ;; сделать второй скриншот
            (let ((image-down
                   (binarization (x-snapshot :x 440 :y 100 :width *snap-width*
                                             :height *snap-height*))))
              ;; сделать таск для них
              (make-tasks image-up image-down)
              ;; сохранить их
              (destructuring-bind (height-down width-down)
                  (array-dimensions image-down)
                (save-png width-down height-down image-down-path image-down :grayscale))
              (destructuring-bind (height-up width-up)
                  (array-dimensions image-up)
                (save-png width-up height-up image-up-path image-up :grayscale))))
          ;; else
          (progn
            ;; провертим экран вниз
            (perform-key-action t 117)
            (sleep .1)
            (perform-key-action nil 117)
            (sleep .5)
            ;; сделать 1 скрин
            (let ((image-down (binarization (x-snapshot :x 440 :y 100 :width *snap-width*
                                                        :height *snap-height*))))
              ;; загружаем последнее изображение
              ;; составляем таск
              (make-tasks (binarization (load-png image-up-path)) image-down)
              ;; сохранить новое изображение
              (destructuring-bind (height-down width-down)
                  (array-dimensions image-down)
                (save-png width-down height-down
                          image-down-path image-down :grayscale))))))

#+END_SRC

Для удобства хранения результатов и тасков создадим для них структуры.

#+NAME: structs
#+BEGIN_SRC lisp :noweb yes

(defstruct task
 (y-points '()) (image-up nil) (image-down nil))

(defstruct result
  black
  white
  y-point
  image-up image-down)

(defstruct append-results
  append-image)


#+END_SRC

Это функция, которая сделает нам задания для 2х изображений.
На выходе make-tasks запушит новую заполненную структуру в пулл тасков/
Сначала создадим пулл результатов и тасков и установим флаг last? в nil. Если при
анализе 2х изображений мы решим, что они одинаковые, флаг изменится на t

#+NAME: make_tasks
#+BEGIN_SRC lisp :noweb yes
  (in-package  #:cl-autogui)

<<structs>>

  (let ((tasks (make-array 100 :fill-pointer 0))
      (last? nil))
  (dotimes (i 100)
    (setf (aref tasks i) (make-task)))
  (let ((results (make-array 100 :fill-pointer 0)))
    (dotimes (i 100)
      (setf (aref results i) (make-result)))
    (let ((append-results (make-array 100 :fill-pointer 0)))
      (dotimes (i 100)
        (setf (aref append-results i) (make-append-results)))

      (defun make-tasks (image-up image-down)
        ;;   (format t "~% make-task tasks length ~A " (length tasks))
        (destructuring-bind (height-down width-down &optional colors-down)
            (array-dimensions image-down)
          (let* ((new-task (aref tasks (fill-pointer tasks)))
                 (y-points))
            (do ((y-point 0 (incf y-point)))
                ((= y-point height-down))
              (setf y-points (cons y-point y-points)))
            (setf (task-y-points new-task) y-points
                  (task-image-up new-task) image-up
                  (task-image-down new-task) image-down)
            ;;(format t "~% new-task ~A" new-task)
            (vector-push new-task tasks))))

    <<get_data>>
    <<find-best>>
#+END_SRC

А теперь все это соберем.

Функция принимает в качестве параметра кол-во ядер на вашем компьютере.
Функция пушит результаты в пулл результатов.
Сначала создадим потоки.
Количество потоков = (кол-во ядер - 1)

#+NAME: get_area_merge_results
#+BEGIN_SRC lisp :noweb yes

    (in-package  #:cl-autogui)

    <<make_tasks>>
    <<make_roll>>

      (defun get-area-merge-results (num-of-cores)
        (let* ((lock (bt:make-lock))
               (thread-names)
               (screen-cnt 0))
          ;; генерим потоки
          (do ((i 0 (incf i)))
              ((= i (- num-of-cores 1)))
            (multiple-value-bind (name value)
                (intern (format nil "thread~A" i))
              (format t "~%  thread ~A" name)

  <<thread>>
#+END_SRC

Функция потока: параметров не принимет, внутри себя использует 2 общих ресурса:
пулл тасков и общий пулл результатов.

Алгоритм действия анализирующего потока:
~начало~
- взять задание из пула тасков (предыдущее изображение, последнее изображение, точка
начала анализа)
~TOP~
- найти максимальный порог белых пикселей в текущем пуле результатов (если их
  нет, устанавливается порог в 50%)
- вызвать analysis  и передать ему порог белых пикселей
- сохранить в текущий пул результатов кол-во черных точек, текущий порог белых точек и координату Y, на
  которой этот результат получен
- задание закончилось?
НЕТ!:
- (не все координаты Y обработаны), вернуться на ~TOP~
ДА! :
- отсортировать результаты из текущего пула результатов
- картинки одинаковые?
Да!
- установить флаг last? в t
- Таски кончились?
Да!:
- если нет, ждать 10 секунд
- если тасков так и не появилось
- вернуть nil
- умереть
Нет!:
- вернуться на ~начало~

Все имена потоков сохраняются в ~thread-names~, чтоб была возможность проверить, живы
ли они.

#+NAME: thread
#+BEGIN_SRC lisp :noweb yes
               (setf name
                     (bt:make-thread
                      (lambda ()
                        (with-open-file (out (format nil "thread~A" i) :direction :output
                                             :if-exists :supersede)
                          ;; (format out "~% ~A" tasks)
                          (tagbody
                           top
                             (format out "~%  f-p tasks ~A" (fill-pointer tasks))
                             ;; если таск есть, заюираем немедленно
                             (let* ((cur-task (if (not (eql (fill-pointer tasks) 0))
                                                  (bt:with-lock-held (lock)
                                                    (vector-pop tasks)))))
                               ;; ОЖИДАЕМ ТАСКИ
                               (if (null cur-task)
                                   (if (eql (fill-pointer tasks) 0)
                                       (progn
                                         (sleep 6)
                                         ;; если тасков так и нет
                                         (if (eql (fill-pointer tasks) 0)
                                             ;; выход
                                             nil
                                             ;; иначе идем забирать таск
                                             (go top)))
                                       ;; таск появился!
                                       ;; забираем
                                       (go top))
                                   ;; ТАСК ЕСТЬ
                                   (let* ((image-up)
                                          (image-down)
                                          (y-points)
                                          (cur-results))
                                     (format out "~% get-area f-p ~A "
                                             (fill-pointer tasks))
                                     ;; получаем данные из таска
                                     (setf image-up (make-bit-image (task-image-up cur-task))
                                           image-down
                                           (make-bit-image (task-image-down cur-task))
                                           y-points (task-y-points cur-task))
                                     (format out "%  y-points ~A "  y-points)
                                     ;; (format out "~% y-point ~A ~% name ~A
                                     ;;                ~% image-up ~A ~% image-down ~A"
                                     ;;         (car cur-task) name image-up image-down)

                                     ;; начинаем анализ
                                     (do ((i (- (length y-points) 1) (- i 1)))
                                         ((< i 0))
                                       ;; получаем текущий y-point
                                       (let ((y-point (car y-points)))
                                         ;; убираем его из списка y-point-ов
                                         (setf y-points (cdr y-points))
                                         ;; если это первая итерация цикла и нет данных
                                         ;; и никаких результатов еще нет
                                         (if (null cur-results)
                                             ;; анализируем изображение с текущим y-point
                                             ;; и допустимым кол-вом белых точек по умолчанию
                                             (let ((amount (analysis
                                                            (xor-area image-up
                                                                      image-down y-point)
                                                            y-point)))
                                               (format out "~% --- before
                                                                  ~% y-point ~A ~% name ~A
                                                                  ~% amount ~A"
                                                       y-point name amount)
                                               ;; если какой-то результат получен,
                                               (if amount
                                                   (progn
                                                     (format out "~% ----
                                                                ~% y-point ~A ~% name ~A
                                                                 ~% amount ~A
                                                                  %---"
                                                             y-point name amount)
                                                     (setf cur-results (cons
                                                                        (cons amount y-point)
                                                                        cur-results)))))
                                             ;; если результаты были, получаем новый
                                             ;; порог белых точек
                                             (let* ((last-result (car cur-results))
                                                    (white (cdr (car last-result)))
                                                    ;; вызываем анализ с этим порогом
                                                    (amount (analysis
                                                             (xor-area image-up
                                                                       image-down
                                                                       y-point)
                                                             y-point white)))
                                               (format out "% white ~A" white)
                                               (format out "~% --- before
                                                                  ~% y-point ~A ~% name ~A
                                                                  ~% amount ~A
                                                                   %---"
                                                       y-point name amount)

                                               ;; если какой-то результат получен,
                                               (if amount
                                                   ;; записываем в в текущий пулл результатов
                                                   ;; (format out "~% amount ~A" amount)
                                                   (progn
                                                     (format out "~% ---
                                                                ~% y-point ~A ~% name ~A
                                                                ~% amount ~A"
                                                             y-point name amount)
                                                     (setf cur-results (cons
                                                                        (cons amount
                                                                              y-point)
                                                                        cur-results))
                                                     ))))))
                                     ;; сортируем результаты
                                     ;; по количеству черных точек
                                     ;; от самого выского результата до самого низкого
                                     (format out " ~% cur-results ~A" cur-results)
                                     (let* ((best-res (find-best cur-results))
                                            (new-result (aref results
                                                              (fill-pointer results))))

                                       (format out "~% sorted-result ~A" best-res)
                                       (setf (result-white new-result) (cdr (car best-res))
                                             (result-black new-result) (car (car best-res))
                                             (result-y-point new-result) (cdr best-res)
                                             (result-image-up new-result)
                                             (task-image-up cur-task)
                                             (result-image-down new-result)
                                             (task-image-down cur-task))
                                       ;; записываем лучший результат
                                       (bt:with-lock-held (lock)
                                         (vector-push new-result results))
                                       ;;(format out "~% results ~A" results)
                                       ;; идем снова брать таск
                                       (go top))))))))))
               ;; сохраняем имя потока
               (setf thread-names (cons name thread-names)))
             )
    <<screen_and_waiting>>
#+END_SRC

Что установит last? в t ? Функция fine-best.
На вход она принимает все результаты анализа одного потока, сначала сортирует по
убыванию черных точек в результате (от самого выского процента до самого низкого),
затем выбирает лучший результат, который оказывается в начале.

Но у нас бывает ситуация, когда один и тот же результат полчен на разных y-point-aх.
Какой результат признать лучшим в этом случае?

Проходимся по всем результатам, имеющим одинаковый процент черных точек. Если среди них
встретился нудевой y-point, значит, картинки одинаковые. Тогда лучшим признается
результат с нулевым y-point, и фраг last? становится t. Если же нулевой y-point не
встретился, то текущий лучший результат оказывается окончательным.

На выходе функция всегда должна вернуть какой-то результат.
#+NAME: find-best
#+BEGIN_SRC lisp :noweb yes
  (in-package  #:cl-autogui)

  (defun find-best (thread-results)
        ;; получаем все результаты от потока
        ;; сортируем
        (let* ((sorted-result
                (sort thread-results
                      #'(lambda (a b)
                          (> (car (car a)) (car (car b)))))
                 ;; (sort thread-results
                 ;;       #'(lambda (a b)
                 ;;           (> (cdr (car a)) (cdr (car b)))))
                 )
               ;; берем лучший из отсортированных
               (best-res (nth 0 sorted-result))
               (i 0))
          (tagbody
           top
             (let ((black-best (car (car best-res)))
                   (cur-black (car (car (nth i sorted-result))))
                   (cur-y (cdr (nth i sorted-result))))
               ;; если кол-во черных точек в результатах одинаковое
               (if (eql black-best cur-black)
                   (progn
                     (setf best-res (nth i sorted-result))
                     ;; и при этом y-point = 0
                     (if (eql cur-y 0)
                         ;; мы нашли последнюю пару картинок
                         (progn
                           (setf last? t)
                           (return-from
                            find-best (nth i sorted-result)))
                         ;; y-point != 0
                         (progn
                           ;; проверяем дальше
                           (incf i)
                           (go top))))
                   ;; кол-во черных точек в результатаз не одинаковое
                   (return-from
                    find-best best-res))))))

#+END_SRC

Здесь главный поток знимается получением данных для анализирующего.
get-data скринит экран, сохраняет изображения и вызывает make-task для каждой новой
пары изображений.

Затем мы ждем некоторое время, чтоб скрининг не происходил слишком быстро, иначе
анализирующие потоки не успевают за главным и скрининг становится почти бесконечным.

Если какие-то результаты есть, проверяем флаг last?. Если он t, мы достигли конца
страницы и скрининг прекращается.

В этом случае просто ожидаем завершения работы анализирующих потоков и вызываем
make-roll, которая должна (в теории... ) склеить все картинки в одно большое
изображение.

#+NAME: screen_and_waiting
#+BEGIN_SRC lisp :noweb yes
  (in-package  #:cl-autogui)

        ;; после того, как создали все потоки и записали их имена,
        ;; скриним экран
        (tagbody
         get-data
           ;;скриним и составляем таски
           (get-data (format nil
                             "~~/Pictures/screen~A.png"
                             screen-cnt)
                     (format nil
                             "~~/Pictures/screen~A.png"
                             (incf screen-cnt)))
           ;; (sleep 4)
           ;; (when (< screen-cnt 12)
           ;;   (progn
           ;;     (format t " ~% < ~A" screen-cnt)
           ;;     (get-data-ofline (format nil
           ;;                              "/home/sonja/Pictures/screen~A.png"
           ;;                              screen-cnt)
           ;;                      (format nil
           ;;                              "/home/sonja/Pictures/screen~A.png"
           ;;                              (incf screen-cnt)))))
           ;; (when (eql screen-cnt 12)
           ;;   (progn
           ;;     (format t " ~% = ~A" screen-cnt)
           ;;     (get-data-ofline (format nil
           ;;                              "/home/sonja/Pictures/screen~A.png"
           ;;                              screen-cnt)
           ;;                      (format nil
           ;;                              "/home/sonja/Pictures/screen~A.png"
           ;;                              screen-cnt)))
           ;;   (incf screen-cnt))

           (sleep 8)
           (format t "~% length results ~A" (fill-pointer results))
           (format t "~% length tasks ~A" (fill-pointer tasks))
           ;;(format t "~% length results ~A" (car results))
           (if (eql (fill-pointer results) 0)
           ;; пока не дойдем до последней пары картинок
           (go get-data)
           (let ((f-p (fill-pointer results)))
             (do ((i 0 (incf i)))
                 (( = i (fill-pointer results)))
               (let ((struct (aref results i)))
                 (format t "~% y ~A black ~A"
                         (result-y-point struct)
                         (result-black struct))))

             ;; (if (eql (fill-pointer tasks) 0)
             ;;     (progn
             ;;       (sleep 15)
             ;;       (if (eql (fill-pointer tasks) 0)
             ;;           (return-from get-area-merge-results nil)

                       (if last?
                           (progn
                             ;; (format t "~% length results ~A" (car results))
                             (tagbody
                              check-threads
                                ;; (format t "~% results ~A tasks~A" (length results)
                                ;;         (length tasks))
                                ;; счетчик живых потоков
                                (let ((alive-threads 0))
                                  (do ((i 0 (incf i)))
                                      ((= i (length thread-names)))
                                    ;;(format t "~% nth ~A thread-name ~A" i (nth i thread-names))
                                    ;; если поток жив
                                    (if (bt:thread-alive-p (nth i thread-names))
                                        ;; (format t "~% alive ~A "(nth i thread-names))
                                        ;; инкрементируем счетчик
                                        (incf alive-threads)))
                                  ;;(format t "~% alive threads ~A " alive-threads)
                                  ;; если живых потоков нет
                                  (if (eql 0 alive-threads)
                                      ;; возвращаем результаты
                                      ;;(progn
                                      ;;(format t "~% results ~A" results)
                                      ;;(return-from get-area-merge-results results)
                                      (progn
                                        (make-roll num-of-cores)
                                        (return-from get-area-merge-results t))
                                        ;; иначе проверяем снова
                                        (progn
                                          (sleep .5)
                                          ;;(format t "~% wait")
                                          (go  check-threads)))))))
                           (go get-data))
           )
           ;;(go get-data))
           )
        )))
       <<demo_get_area_merge_results_tests>>
      ))
  <<get_area_merge_results_tests>>
#+END_SRC

Теперь сама склейка.
Принимает на вход количество ядер, поскольку внутри себя вызывает функцию генерации
потоков.
Вызывается только после того, как все картинки со страницы выдачи были отскринены.


Механизм работы:
- берет результаты анализа и склеиает картинки до тех пор, пока результаты не кончатся
- каждое склеенное изображение сохраняется в пулл склеенных изображений
- затем эти изображения вынимаются и из них составляются таски
- вызывается функция генерации потоков make-threads. Содержит в себе практически
  неизмененную функцию потока из get-area-merge-reasults (различие только в том, что
  эта если не обнаружит тасков, выходит тут же, а не ждет их появления)
- make-threads пушит результаты анализа в пулл результатов
- затем мы рекурсивно вызываем make-roll
- условие завершения рекурсии - получение единого изображения

#+NAME: make_roll
#+BEGIN_SRC lisp :noweb yes
<<make_threads>>
  (in-package  #:cl-autogui)
(defun make-roll (num-of-cores)
        (tagbody
         top
           (format t "~% make-roll")
           (format t "~% top f-p results ~A"
                   (fill-pointer results))
           ;; результаты анализа есть?
           (if (eql (fill-pointer results) 0)
               ;; нет
               (progn
                 (sleep 10)
                 (if (eql (fill-pointer results) 0)
                     ;; все еще нет
                     (format t "~% no results")
                     (go top)))
                 ;; результаты есть!
               (tagbody
                append-images
                  (format t "~% append-images")
                  ;; получаем результаты анализа
                  (let* ((cur-task (vector-pop results))
                         (image-up (result-image-up cur-task))
                         (image-down (result-image-up cur-task))
                         (y-point (result-y-point cur-task)))
                    (destructuring-bind (height-down width-down)
                        (array-dimensions image-down)
                      (destructuring-bind (height-up width-up)
                          (array-dimensions image-up)
                        (format t "~% height-down ~A width-down ~A height-up ~A width-up ~A"
                                height-down width-down height-up width-up)))
                    (let ((appended-image (append-image image-up image-down y-point)))
                      ;; пушим результаты склейки
                      (vector-push appended-image append-results))
                    ;; результаты аналза кончились?
                    (if (not (eql (fill-pointer results) 0))
                        ;; нет!
                        (go append-images)
                        ;; картинка получилась одна?
                        (if (eql (fill-pointer append-results) 1)
                            ;; да!
                            (let ((roll (vector-pop append-results)))
                              (destructuring-bind (height width)
                                  (array-dimensions roll)
                                (save-png width height "~/Pictures/resut.png"
                                          roll :grayscale)))
                            ;; нет!
                            ;; делаем таски из новых изображений
                            (let ((flag)
                                  (image-down)
                                  (image-up))
                              (tagbody
                               do-tasks
                                 (if (null flag)
                                     (progn
                                       (setf image-down (vector-pop append-results))
                                       (setf image-up (vector-pop append-results))
                                       (setf flag 1)
                                       (make-tasks image-up image-down)
                                       (do ((i 0 (incf i)))
                                           (( = i (fill-pointer tasks)))
                                         (let ((fuck (aref tasks i)))
                                           (format t "~% last y-point ~A"
                                                   (last (task-y-points fuck)))
                                           (destructuring-bind (height-down width-down)
                                               (array-dimensions (task-image-down fuck))
                                             (destructuring-bind (height-up width-up)
                                                 (array-dimensions (task-image-up fuck))
                                               (format t "~% task height-down ~A width-down ~A height-up ~A width-up ~A"
                                                       height-down width-down
                                                       height-up width-up))))
                                         )

                                       ;; склеенные картинки кончились?
                                       (if (not (eql (fill-pointer append-results) 0))
                                           ;; нет
                                           (go do-tasks)
                                           ;; да
                                           (progn
                                             (make-threads num-of-cores)
                                             (format t "~% nil go top")
                                             (format t "~% nil f-p ~A"
                                                     (fill-pointer results))
                                             (go top))))
                                     (progn
                                       (setf image-down (aref append-results
                                                              (fill-pointer
                                                               append-results)))
                                       (setf image-up (vector-pop append-results))
                                       (make-tasks image-up image-down)
                                       (do ((i 0 (incf i)))
                                           (( = i (fill-pointer tasks)))
                                         (let ((fuck (aref tasks i)))
                                           (format t "~% last y-point ~A"
                                                   (nth 0 (task-y-points fuck)))
                                           (destructuring-bind (height-down width-down)
                                               (array-dimensions (task-image-down fuck))
                                             (destructuring-bind (height-up width-up)
                                                 (array-dimensions (task-image-up fuck))
                                               (format t "~% task height-down ~A width-down ~A height-up ~A width-up ~A"
                                                       height-down width-down
                                                       height-up width-up))))
                                         )

                                       ;; склеенные картинки кончились?
                                       (if (not (eql (fill-pointer append-results) 0))
                                           ;; нет
                                           (go do-tasks)
                                           ;; да
                                           (progn
                                             (make-threads num-of-cores)
                                             (format t "~% flag t go top")
                                             (format t "~% t f-p ~A"
                                                     (fill-pointer results))
                                             (go top))))))))))))
           ))

<<make-roll-test>>
#+END_SRC

#+NAME: make_threads
#+BEGIN_SRC lisp :noweb yes

      (defun make-threads (num-of-cores)
        (let* ((lock (bt:make-lock))
               (thread-names))
          ;; генерим потоки
          (do ((i 0 (incf i)))
              ((= i (- num-of-cores 1)))
            (multiple-value-bind (name value)
                (intern (format nil "thread~A" i))
              (format t "~%  thread ~A" name)
              (in-package  #:cl-autogui)
              (setf name
                    (bt:make-thread
                     (lambda ()
                       (with-open-file (out (format nil "thread~A" i) :direction :output
                                            :if-exists :supersede)
                         ;; (format out "~% ~A" tasks)
                         (tagbody
                          top
                            (format out "~%  f-p tasks ~A" (fill-pointer tasks))
                            ;; если таск есть, заюираем немедленно
                            (let* ((cur-task (if (not (eql (fill-pointer tasks) 0))
                                                 (bt:with-lock-held (lock)
                                                   (vector-pop tasks)))))
                              ;; таск есть?
                              (if (null cur-task)
                                  ;; нет
                                  nil
                                  ;; да
                                  (let* ((image-up)
                                         (image-down)
                                         (y-points)
                                         (cur-results))
                                    (format out "~% get-area f-p ~A "
                                            (fill-pointer tasks))
                                    ;; получаем данные из таска
                                    (setf image-up (make-bit-image
                                                    (task-image-up cur-task))
                                          image-down
                                          (make-bit-image (task-image-down cur-task))
                                          y-points (task-y-points cur-task))
                                    (format out "%  y-points ~A "  y-points)
                                    ;; (format out "~% y-point ~A ~% name ~A
                                    ;;                ~% image-up ~A ~% image-down ~A"
                                    ;;         (car cur-task) name image-up image-down)

                                    ;; начинаем анализ
                                    (destructuring-bind (height-up width-up)
                                        (array-dimensions image-up)
                                      (do ((i (- height-up 1) (- i 1)))
                                          ((< i 0))
                                        ;; получаем текущий y-point
                                        (let ((y-point (car y-points)))
                                          ;; убираем его из списка y-point-ов
                                          (setf y-points (cdr y-points))
                                          ;; если это первая итерация цикла и нет данных
                                          ;; и никаких результатов еще нет
                                          (if (null cur-results)
                                              ;; анализируем изображение с текущим y-point
                                              ;; и допустимым кол-вом белых точек по умолчанию
                                              (let ((amount (analysis
                                                             (xor-area image-up
                                                                       image-down y-point)
                                                             y-point)))
                                                ;; (format out "~% --- before
                                                ;;                    ~% y-point ~A ~% name ~A
                                                ;;                    ~% amount ~A"
                                                ;;         y-point name amount)
                                                ;; если какой-то результат получен,
                                                (if amount
                                                    (progn
                                                      ;; (format out "~% ----
                                                      ;;            ~% y-point ~A ~% name ~A
                                                      ;;             ~% amount ~A
                                                      ;;              %---"
                                                      ;;         y-point name amount)
                                                      (setf cur-results (cons
                                                                         (cons amount y-point)
                                                                         cur-results)))))
                                              ;; если результаты были, получаем новый
                                              ;; порог белых точек
                                              (let* ((last-result (car cur-results))
                                                     (white (cdr (car last-result)))
                                                     ;; вызываем анализ с этим порогом
                                                     (amount (analysis
                                                              (xor-area image-up
                                                                        image-down
                                                                        y-point)
                                                              y-point white)))
                                                ;; (format out "% white ~A" white)
                                                ;; (format out "~% --- before
                                                ;;                    ~% y-point ~A ~% name ~A
                                                ;;                    ~% amount ~A
                                                ;;                     %---"
                                                ;;         y-point name amount)

                                                ;; если какой-то результат получен,
                                                (if amount
                                                    ;; записываем в в текущий пулл результатов
                                                    ;; (format out "~% amount ~A" amount)
                                                    (progn
                                                      ;; (format out "~% ---
                                                      ;;            ~% y-point ~A ~% name ~A
                                                      ;;            ~% amount ~A"
                                                      ;;         y-point name amount)
                                                      (setf cur-results (cons
                                                                         (cons amount
                                                                               y-point)
                                                                         cur-results))
                                                      )))))))
                                    ;; сортируем результаты
                                    ;; по количеству черных точек
                                    ;; от самого выского результата до самого низкого
                                    (format out " ~% cur-results ~A" cur-results)
                                    (let* ((best-res (find-best cur-results))
                                           (new-result (aref results
                                                             (fill-pointer results))))

                                      (format out "~% sorted-result ~A" best-res)
                                      (setf (result-white new-result) (cdr (car best-res))
                                            (result-black new-result) (car (car best-res))
                                            (result-y-point new-result) (cdr best-res)
                                            (result-image-up new-result)
                                            (task-image-up cur-task)
                                            (result-image-down new-result)
                                            (task-image-down cur-task))
                                      ;; записываем лучший результат
                                      (bt:with-lock-held (lock)
                                        (vector-push new-result results))
                                      ;;(format out "~% results ~A" results)
                                      ;; идем снова брать таск
                                      (go top))))))))))
            ;; сохраняем имя потока
              (setf thread-names (cons name thread-names)))
            )
          (tagbody
           check-threads
             ;; (format t "~% results ~A tasks~A" (length results)
             ;;         (length tasks))
             ;; счетчик живых потоков
             (let ((alive-threads 0))
               (do ((i 0 (incf i)))
                   ((= i (length thread-names)))
                 ;;(format t "~% nth ~A thread-name ~A" i (nth i thread-names))
                 ;; если поток жив
                 (if (bt:thread-alive-p (nth i thread-names))
                     ;; (format t "~% alive ~A "(nth i thread-names))
                     ;; инкрементируем счетчик
                     (incf alive-threads)))
               ;;(format t "~% alive threads ~A " alive-threads)
               ;; если живых потоков нет
               (if (eql 0 alive-threads)
                   ;; возвращаем результаты
                   ;;(progn
                   ;;(format t "~% results ~A" results)
                   ;;(return-from get-area-merge-results results)
                   (return-from make-threads t)
                   ;; иначе проверяем снова
                   (progn
                     (sleep .5)
                     ;;(format t "~% wait")
                     (go  check-threads)))))))


#+END_SRC

* Офлайн демо версия

Это упрощенный офлайн демо-тест.
Схематично работает так же, как основной механизм.

- собрать картинки
- создать для них таски
- проанализировать их
- найти лучшие результаты
- по полученным результатам склеить
- выход

Отличие от основного механизма:
- скрины должны быть сделаны заранее, демо версия их не делает, а только загружает
- отсутствие многопоточности, потому рекомендуется для анализа запускать не более 3-4
  картинок. Сделано для упрощения отладки.
- склейка происходит не "до победы", т.е. не до составления одного общего рулона из
  всех картинок. а только по имеющимся результатам. Инаыми словами, сколько тасков было
  создано, столько картинок-склеекполучается на выходе.

Получение картинок:
загружаем картинки, тут же бинаризируем их и делаем таски.

#+NAME: get-data-ofline
#+BEGIN_SRC lisp :noweb yes

(defun get-data-ofline (image-up image-down)
      (format t "~% get-data-ofline")
        (make-tasks (binarization (load-png image-up))
                   (binarization (load-png image-down))))

#+END_SRC

Сборка и анализ тасков:
Сначала загружаем картинки и делаем таски для них
Когда нужно кол-во картинок загружено (определяется screen-cnt), дотсаем из каждого
таска данные для анализа: Image-up и image-down, список y-points, т.к. список координат
Y, по которым xor-area и analysis будут ксорить и анализировать картинки .
После того, как анализ одного таска полностью завершен, сортируем его реультаты и ищем
лучший. Затем записываем лучший результат и 2 картинки, на которых он был получен, в
пулл результатов.

Как только все картинки проанализированы, вызываем склейку.

#+NAME: demo_get_area_merge_results_tests
#+BEGIN_SRC lisp :noweb yes

(defun demo-get-area-merge-results ()
      (let ((screen-cnt 0))
        (tagbody top
            (get-data-ofline (format nil
                                     "~~/Pictures/screen~A.png"
                                     screen-cnt)
                             (format nil
                                     "~~/Pictures/screen~A.png"
                                     (incf screen-cnt)))
           ;; делаем таски для 3 картинок
           (if (< screen-cnt 3)
               (go top)
               (progn
                 (format t "~% demo: amount of tasks" (fill-pointer tasks))
                 (let* ((image-up)
                        (image-down)
                        (y-points)
                        (cur-results)
                        (cur-task))
                   (do ((i 0 (incf i)))
                       (( = i (fill-pointer tasks)))
                     ;; получаем данные из таска
                     (setf cur-task (aref tasks i)
                           image-up (make-bit-image (task-image-up cur-task))
                           image-down (make-bit-image (task-image-down cur-task))
                           y-points (task-y-points cur-task))
                     (do ((i (length y-points) (decf i)))
                         (( = i 0))
                       (let*((y-point (car y-points))
                             (amount (analysis (xor-area image-up image-down y-point)
                                               y-point)))
                         (setf y-points (cdr y-points))
                         (if amount
                             ;; записываем в текущий пулл результатов
                             (progn
                               (setf cur-results (cons
                                                  (cons amount
                                                        y-point)
                                                  cur-results))))))
                     (format t "~% cur-results i: ~A
                              ~% ~A" i cur-results)
                     ;; отсортировали результаты анализа текущего таска
                     (let* ((best-res (find-best cur-results))
                            (new-result (aref results
                                              (fill-pointer results))))
                       (format t "~% i: ~A best-result ~A" i best-res)

                       (setf (result-white new-result) (cdr (car best-res))
                             (result-black new-result) (car (car best-res))
                             (result-y-point new-result) (cdr best-res)
                             (result-image-up new-result)
                             (task-image-up cur-task)
                             (result-image-down new-result)
                             (task-image-down cur-task))

                       ;; записываем лучший результат
                       (vector-push new-result results)
                       (setf cur-results nil)
                       ))
                   (make-roll-test)
                   ))))))

#+END_SRC

Данная функция будет брать данные из пула результатов и склеивать по ним картинки.

#+NAME: make-roll-test
#+BEGIN_SRC lisp :noweb yes

      (defun make-roll-test ()
        (format t "~% make-roll: amount of results ~A"
                (fill-pointer results))
        (let ((cnt 0))
          (tagbody
           append-images
             (format t "~% append-images")
             ;; получаем результаты анализа
             (let* ((cur-task (vector-pop results))
                    (image-up (result-image-up cur-task))
                    (image-down (result-image-down cur-task))
                    (y-point (result-y-point cur-task)))
                ;; отладочный вывод
               (destructuring-bind (height-down width-down)
                   (array-dimensions image-down)
                 (destructuring-bind (height-up width-up)
                     (array-dimensions image-up)
                   (format t
                           "~% --------------------
                                   ~% height-down ~A width-down ~A
                                   ~% height-up ~A width-up ~A
                                   ~% --------------------"
                           height-down width-down height-up width-up)))
               ;; склейка
               (let ((appended-image
                      (append-image image-up image-down y-point)))
                 (destructuring-bind (height width)
                     (array-dimensions appended-image)
                   (save-png width height
                             (format nil "~~/Pictures/resut~A.png" cnt)
                             appended-image :grayscale))
                 (incf cnt)
                 ;; пушим результаты склейки
                 ;; (в принципе, это не необходимо, но может пригодиться позже)
                 (vector-push appended-image append-results))

               ;; результаты аналза кончились?
               (if (not (eql (fill-pointer results) 0))
                   ;; нет!
                   (go append-images)
                   t)))))

#+END_SRC

Для полного счастья не хватает только тестов.
Внимание! Пути на вашем компе могут отличаться, как и имена картинок.
Если попытаться вернуть результаты не в локальную переменную, в поток nil
(наш вывод в мини-буфере внизу экрана), память кончается.

#+NAME: get_area_merge_results_tests
#+BEGIN_SRC lisp :noweb yes
  (in-package  #:cl-autogui)

  ;; (time
  ;; (block make-task-test
  ;;    (open-browser "/usr/bin/firefox" "https://spb.hh.ru/")
  ;;    (sleep 8)
  ;;    (let ((result (get-area-merge-results 4)))
  ;;    )))

  ;; (time
  ;;  (block ofline-demo-test
  ;;    (demo-get-area-merge-results)))

#+END_SRC

* Идеи

1. У каждой пары анализируемых изображений должен быть свой пулл результатов. Этот пул
   создается внутри потока. Туда записывается 2 изображения и результаты для них, вида
   ((черные точки. белые точки. y-point) изображение 1 изображение 2)
   На выходе поток сортирует результаты и возвращает наилучший результат в общий пул
   результатов вида ((черные точки . y-point) изображение 1 изображение 2)

_______________________________________________________________________________

2. Склейка
выполняет после получения результатов для всех тасков
получаем массив с подсписками.

склеить картинку
если длина results != 1, т.е мы не получили цнлый рулон картинку
(make-tasks)
~top~
results = tasks
очистить results
(setf results analysis)
записать полученные массивы в results
если длина results != 1, т.е мы не получили цнлый рулон картинку
~go top~

* Экспорт

Теперь можно экспортировать некоторые функции и переметиться в созданный пакет

#+NAME: parcer
#+BEGIN_SRC lisp :tangle parser.lisp :noweb yes
<<libs>>

<<defparams>>

<<open-browser>>

<<display-macros>>

<<x-snapshot>>

<<save-png>>

<<fake-events>>

<<make-bit-image>>

<<append-xor>>

<<get_area_merge_results>>
#+END_SRC
